import {Model} from 'mobx-collection-store';

import IDictionary from './interfaces/IDictionary';
import IRequestOptions from './interfaces/IRequestOptions';
import * as JsonApi from './interfaces/JsonApi';

import {config, create, fetchLink, remove, update} from './NetworkUtils';
import {Response} from './Response';
import {Store} from './Store';
import {mapItems, objectForEach} from './utils';

interface IInternal {
  relationships?: IDictionary<JsonApi.IRelationship>;
  meta?: Object;
  links?: IDictionary<JsonApi.ILink>;
  persisted?: boolean;
}

export class Record extends Model {

  /**
   * Type property of the record class
   *
   * @static
   *
   * @memberOf Record
   */
  public static typeAttribute = 'type';

  /**
   * Record id
   *
   * @type {(number|string)}
   * @memberOf Record
   */

  public id: number|string;
  /**
   * Record type
   *
   * @type {string}
   * @memberOf Record
   */
  public type: string;

  /**
   * Internal metadata
   *
   * @private
   * @type {IInternal}
   * @memberOf Record
   */
  private __internal: IInternal;

  /**
   * Cache link fetch requests
   *
   * @private
   * @type {IDictionary<Promise<Response>>}
   * @memberOf Record
   */
  private __linkCache: IDictionary<Promise<Response>> = {};

  /**
   * Get record relationship links
   *
   * @returns {IDictionary<JsonApi.IRelationship>} Record relationship links
   *
   * @memberOf Record
   */
  public getRelationshipLinks(): IDictionary<JsonApi.IRelationship> {
    return this.__internal && this.__internal.relationships;
  }

  /**
   * Get record metadata
   *
   * @returns {Object} Record metadata
   *
   * @memberOf Record
   */
  public getMeta(): Object {
    return this.__internal && this.__internal.meta;
  }

  /**
   * Get record links
   *
   * @returns {IDictionary<JsonApi.ILink>} Record links
   *
   * @memberOf Record
   */
  public getLinks(): IDictionary<JsonApi.ILink> {
    return this.__internal && this.__internal.links;
  }

  /**
   * Fetch a record link
   *
   * @param {string} name Name of the link
   * @param {IRequestOptions} [options] Server options
   * @returns {Promise<Response>} Response promise
   *
   * @memberOf Record
   */
  public fetchLink(name: string, options?: IRequestOptions): Promise<Response> {
    if (!(name in this.__linkCache)) {
      const link = ('links' in this.__internal && name in this.__internal.links) ?
        this.__internal.links[name] : null;
      this.__linkCache[name] = fetchLink(link, this.__collection as Store, options && options.headers, options);
    }

    return this.__linkCache[name];
  }

  /**
   * Get the persisted state
   *
   * @readonly
   * @private
   * @type {boolean}
   * @memberOf Record
   */
  private get __persisted(): boolean {
    return (this.__internal && this.__internal.persisted) || false;
  }

  /**
   * Set the persisted state
   *
   * @private
   *
   * @memberOf Record
   */
  private set __persisted(state: boolean) {
    this.__internal = this.__internal || {};
    this.__internal.persisted = state;
  }

  /**
   * Serialize the record into JSON API format
   *
   * @returns {JsonApi.IRecord} JSON API formated record
   *
   * @memberOf Record
   */
  public toJsonApi(): JsonApi.IRecord {
    const attributes = this.toJS();
    delete attributes.id;
    delete attributes.type;

    const data: JsonApi.IRecord = {
      attributes,
      id: this.__persisted ? this.id : undefined, // TODO: Allow autogenerated IDs in the future
      type: this.type,
    };

    // tslint:disable-next-line:no-string-literal
    const refs: IDictionary<string> = this['__refs'];
    objectForEach(refs, (key) => {
      data.relationships = data.relationships || {};
      const rel = mapItems(this[`${key}Id`], (id: number|string) => ({id, type: refs[key]}));
      data.relationships[key] = {data: rel} as JsonApi.IRelationship;

      delete data.attributes[key];
      delete data.attributes[`${key}Id`];
      delete data.attributes[`${key}Meta`];
    });

    delete data.attributes.__internal;
    delete data.attributes.__type__;

    return data;
  }

  /**
   * Saves (creates or updates) the record to the server
   *
   * @param {IRequestOptions} [options] Server options
   * @returns {Promise<Record>} Returns the record is successful or rejects with an error
   *
   * @memberOf Record
   */
  public save(options?: IRequestOptions): Promise<Record> {
    const store = this.__collection as Store;
    const data = this.toJsonApi();
    const requestMethod = this.__persisted ? update : create;
    return requestMethod(store, this.__getUrl(), {data}, options && options.headers)
      .then((response: Response) => {
        if (response.error) {
          throw response.error;
        }

        this.__persisted = true;
        return response.data;
      });
  }

  /**
   * Remove the records from the server and store
   *
   * @param {IRequestOptions} [options] Server options
   * @returns {Promise<boolean>} Resolves true if successfull or rejects if there was an error
   *
   * @memberOf Record
   */
  public remove(options?: IRequestOptions): Promise<boolean> {
    const store = this.__collection as Store;
    if (!this.__persisted) {
      this.__collection.remove(this.type, this.id);
      return Promise.resolve(true);
    }
    return remove(store, this.__getUrl(), options && options.headers)
      .then((response: Response) => {
        if (response.error) {
          throw response.error;
        }

        this.__persisted = false;
        this.__collection.remove(this.type, this.id);
        return true;
      });
  }

  /**
   * Set the persisted status of the record
   *
   * @param {boolean} state Is the record persisted on the server
   *
   * @memberOf Record
   */
  public setPersisted(state: boolean) {
    this.__persisted = state;
  }

  /**
   * Get the URL that should be used for the API calls
   *
   * @private
   * @returns {string} API URL
   *
   * @memberOf Record
   */
  private __getUrl(): string {

    const links = this.getLinks();
    if (links && links.self) {
      const self: JsonApi.ILink = links.self;
      return typeof self === 'string' ? self : self.href;
    }

    return this.__persisted
      ? `${config.baseUrl}${this.type}/${this.id}`
      : `${config.baseUrl}${this.type}`;
  }
}
